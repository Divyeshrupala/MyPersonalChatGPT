// ðŸ“ PROJECT MANAGER - Save, Organize, and Export Results

export class ProjectManager {
  constructor() {
    this.projects = this.loadProjects();
  }

  // Load projects from localStorage
  loadProjects() {
    try {
      const saved = localStorage.getItem('aiProjects');
      return saved ? JSON.parse(saved) : [];
    } catch (e) {
      return [];
    }
  }

  // Save projects to localStorage
  saveProjects() {
    try {
      localStorage.setItem('aiProjects', JSON.stringify(this.projects));
    } catch (e) {
      console.warn('Could not save projects:', e);
    }
  }

  // Create new project
  createProject(data) {
    const project = {
      id: this.generateId(),
      title: data.title || 'Untitled Project',
      type: data.type || 'chat',
      content: data.content || '',
      template: data.template || null,
      provider: data.provider || 'unknown',
      model: data.model || '',
      inputs: data.inputs || {},
      tags: data.tags || [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      favorite: false,
      exported: false,
      wordCount: this.countWords(data.content || ''),
      category: data.category || 'general'
    };

    this.projects.unshift(project);
    this.saveProjects();
    return project;
  }

  // Update existing project
  updateProject(id, updates) {
    const index = this.projects.findIndex(p => p.id === id);
    if (index !== -1) {
      this.projects[index] = {
        ...this.projects[index],
        ...updates,
        updatedAt: new Date().toISOString(),
        wordCount: updates.content ? this.countWords(updates.content) : this.projects[index].wordCount
      };
      this.saveProjects();
      return this.projects[index];
    }
    return null;
  }

  // Delete project
  deleteProject(id) {
    this.projects = this.projects.filter(p => p.id !== id);
    this.saveProjects();
  }

  // Get project by ID
  getProject(id) {
    return this.projects.find(p => p.id === id);
  }

  // Get all projects
  getAllProjects() {
    return this.projects;
  }

  // Get projects by category
  getProjectsByCategory(category) {
    return this.projects.filter(p => p.category === category);
  }

  // Get favorite projects
  getFavoriteProjects() {
    return this.projects.filter(p => p.favorite);
  }

  // Get recent projects
  getRecentProjects(limit = 10) {
    return this.projects
      .sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt))
      .slice(0, limit);
  }

  // Search projects
  searchProjects(query) {
    const searchTerm = query.toLowerCase();
    return this.projects.filter(project => 
      project.title.toLowerCase().includes(searchTerm) ||
      project.content.toLowerCase().includes(searchTerm) ||
      project.tags.some(tag => tag.toLowerCase().includes(searchTerm))
    );
  }

  // Toggle favorite
  toggleFavorite(id) {
    const project = this.getProject(id);
    if (project) {
      project.favorite = !project.favorite;
      project.updatedAt = new Date().toISOString();
      this.saveProjects();
      return project.favorite;
    }
    return false;
  }

  // Add tag to project
  addTag(id, tag) {
    const project = this.getProject(id);
    if (project && !project.tags.includes(tag)) {
      project.tags.push(tag);
      project.updatedAt = new Date().toISOString();
      this.saveProjects();
    }
  }

  // Remove tag from project
  removeTag(id, tag) {
    const project = this.getProject(id);
    if (project) {
      project.tags = project.tags.filter(t => t !== tag);
      project.updatedAt = new Date().toISOString();
      this.saveProjects();
    }
  }

  // Get all unique tags
  getAllTags() {
    const tags = new Set();
    this.projects.forEach(project => {
      project.tags.forEach(tag => tags.add(tag));
    });
    return Array.from(tags).sort();
  }

  // Export project as different formats
  exportProject(id, format = 'txt') {
    const project = this.getProject(id);
    if (!project) return null;

    const timestamp = new Date().toLocaleString();
    
    switch (format) {
      case 'txt':
        return this.exportAsTxt(project, timestamp);
      case 'md':
        return this.exportAsMarkdown(project, timestamp);
      case 'html':
        return this.exportAsHtml(project, timestamp);
      case 'json':
        return this.exportAsJson(project);
      default:
        return this.exportAsTxt(project, timestamp);
    }
  }

  // Export as plain text
  exportAsTxt(project, timestamp) {
    return `${project.title}
Generated on: ${timestamp}
Provider: ${project.provider}
Model: ${project.model}
Category: ${project.category}
Tags: ${project.tags.join(', ')}

${project.content}

---
Generated by Multi-AI Assistant`;
  }

  // Export as Markdown
  exportAsMarkdown(project, timestamp) {
    return `# ${project.title}

**Generated on:** ${timestamp}  
**Provider:** ${project.provider}  
**Model:** ${project.model}  
**Category:** ${project.category}  
**Tags:** ${project.tags.join(', ')}  

---

${project.content}

---
*Generated by Multi-AI Assistant*`;
  }

  // Export as HTML
  exportAsHtml(project, timestamp) {
    return `<!DOCTYPE html>
<html>
<head>
    <title>${project.title}</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .header { border-bottom: 2px solid #333; padding-bottom: 10px; margin-bottom: 20px; }
        .meta { color: #666; font-size: 14px; margin-bottom: 20px; }
        .content { line-height: 1.6; }
        .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #ccc; color: #666; font-size: 12px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>${project.title}</h1>
    </div>
    <div class="meta">
        <p><strong>Generated on:</strong> ${timestamp}</p>
        <p><strong>Provider:</strong> ${project.provider}</p>
        <p><strong>Model:</strong> ${project.model}</p>
        <p><strong>Category:</strong> ${project.category}</p>
        <p><strong>Tags:</strong> ${project.tags.join(', ')}</p>
    </div>
    <div class="content">
        ${project.content.replace(/\n/g, '<br>')}
    </div>
    <div class="footer">
        <p>Generated by Multi-AI Assistant</p>
    </div>
</body>
</html>`;
  }

  // Export as JSON
  exportAsJson(project) {
    return JSON.stringify(project, null, 2);
  }

  // Download project file
  downloadProject(id, format = 'txt') {
    const project = this.getProject(id);
    if (!project) return;

    const content = this.exportProject(id, format);
    const filename = `${project.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.${format}`;
    
    const blob = new Blob([content], { type: this.getMimeType(format) });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    // Mark as exported
    this.updateProject(id, { exported: true });
  }

  // Get MIME type for format
  getMimeType(format) {
    const mimeTypes = {
      'txt': 'text/plain',
      'md': 'text/markdown',
      'html': 'text/html',
      'json': 'application/json'
    };
    return mimeTypes[format] || 'text/plain';
  }

  // Get project statistics
  getStatistics() {
    const total = this.projects.length;
    const favorites = this.projects.filter(p => p.favorite).length;
    const categories = {};
    const providers = {};
    let totalWords = 0;

    this.projects.forEach(project => {
      // Count categories
      categories[project.category] = (categories[project.category] || 0) + 1;
      
      // Count providers
      providers[project.provider] = (providers[project.provider] || 0) + 1;
      
      // Count words
      totalWords += project.wordCount || 0;
    });

    return {
      total,
      favorites,
      totalWords,
      categories,
      providers,
      averageWordsPerProject: total > 0 ? Math.round(totalWords / total) : 0
    };
  }

  // Generate unique ID
  generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }

  // Count words in text
  countWords(text) {
    return text.trim().split(/\s+/).filter(word => word.length > 0).length;
  }

  // Clear all projects
  clearAllProjects() {
    this.projects = [];
    localStorage.removeItem('aiProjects');
  }

  // Export all projects
  exportAllProjects() {
    const exportData = {
      projects: this.projects,
      statistics: this.getStatistics(),
      exportDate: new Date().toISOString(),
      version: '1.0'
    };

    const content = JSON.stringify(exportData, null, 2);
    const blob = new Blob([content], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `ai_projects_backup_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // Import projects
  importProjects(data) {
    try {
      const importData = typeof data === 'string' ? JSON.parse(data) : data;
      if (importData.projects && Array.isArray(importData.projects)) {
        this.projects = [...this.projects, ...importData.projects];
        this.saveProjects();
        return importData.projects.length;
      }
    } catch (e) {
      console.error('Import failed:', e);
    }
    return 0;
  }
}

// Create global instance
export const projectManager = new ProjectManager();